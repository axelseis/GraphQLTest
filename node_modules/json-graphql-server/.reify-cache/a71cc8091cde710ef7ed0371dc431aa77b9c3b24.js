"use strict";var pluralize;module.watch(require('inflection'),{pluralize(v){pluralize=v}},0);var GraphQLJSON;module.watch(require('graphql-type-json'),{default(v){GraphQLJSON=v}},1);var all;module.watch(require('./Query/all'),{default(v){all=v}},2);var meta;module.watch(require('./Query/meta'),{default(v){meta=v}},3);var single;module.watch(require('./Query/single'),{default(v){single=v}},4);var create;module.watch(require('./Mutation/create'),{default(v){create=v}},5);var update;module.watch(require('./Mutation/update'),{default(v){update=v}},6);var remove;module.watch(require('./Mutation/remove'),{default(v){remove=v}},7);var entityResolver;module.watch(require('./Entity'),{default(v){entityResolver=v}},8);var getTypeFromKey;module.watch(require('../nameConverter'),{getTypeFromKey(v){getTypeFromKey=v}},9);var DateType;module.watch(require('../introspection/DateType'),{default(v){DateType=v}},10);var hasType;module.watch(require('../introspection/hasType'),{default(v){hasType=v}},11);













const getQueryResolvers = (entityName, data) => ({
    [`all${pluralize(entityName)}`]: all(data),
    [`_all${pluralize(entityName)}Meta`]: meta(data),
    [entityName]: single(data),
});

const getMutationResolvers = (entityName, data) => ({
    [`create${entityName}`]: create(data),
    [`update${entityName}`]: update(data),
    [`remove${entityName}`]: remove(data),
});

module.exportDefault(data => {
    return Object.assign(
        {},
        {
            Query: Object.keys(data).reduce(
                (resolvers, key) =>
                    Object.assign(
                        {},
                        resolvers,
                        getQueryResolvers(getTypeFromKey(key), data[key])
                    ),
                {}
            ),
            Mutation: Object.keys(data).reduce(
                (resolvers, key) =>
                    Object.assign(
                        {},
                        resolvers,
                        getMutationResolvers(getTypeFromKey(key), data[key])
                    ),
                {}
            ),
        },
        Object.keys(data).reduce(
            (resolvers, key) =>
                Object.assign({}, resolvers, {
                    [getTypeFromKey(key)]: entityResolver(key, data),
                }),
            {}
        ),
        hasType('Date', data) ? { Date: DateType } : {}, // required because makeExecutableSchema strips resolvers from typeDefs
        hasType('JSON', data) ? { JSON: GraphQLJSON } : {} // required because makeExecutableSchema strips resolvers from typeDefs
    );
});
